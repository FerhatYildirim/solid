{"name":"Solid","tagline":"","body":"#SOLID Prensipleri\r\n\r\nSolid prensipleri yazılım ile ilgili kullanılan 5 maddelik prensip serisidir. \r\n   Tasarım kalıplarına uygun programlar geliştirildiğinde bile bazı sorunlar çıkmış olup, \r\nSOLID bu sorunlara çözüm olarak tasarlanmıştır. \r\n\r\n####1) Esnemezlik (Rigitidy) : \r\n    Yazılımın geliştirilmesi ve ekleme yapılması ile ilgili sorunlar.\r\n####2) Kırılganlık (Fragility) : \r\n    Yazılımın bir yerinde yapılan değişikliğin başka bir bölümü olumsuz etkilemesi.\r\n####3) Sabitlik (Immobility) : \r\n    Geliştirilen bir bölümün başka bir yerde kullanılamaması. \r\n\r\n   Bu sorunlar sadece yazılımın sorunları değil, genel olarak yaşamımızda olan sorunlardır ve bunları \r\notomatik olarak çözümleriz bazen. Bazende çözemediğimiz için sorunlarla karşılaşırız. \r\n\r\n   Bir örnek verelim: Bir lokanta açalım ve bunu yaparken SOLID'e nasıl uyduğumuza bakalım. \r\n\r\n##1) (S)ingle Responsibility (Tek Sorumluluk) : \r\n   Mutfağımızda tezgahımızı hem yemek malzemelerini doğramak hem servis hem bulaşık yıkamak için \r\nkullanıyor olsaydık ne olurdu? Hem müşteriler açısından \"hijyenik\" olmaktan uzak hemde orda çalışacak kişi ya da kişiler\r\niçin karmaşık bir durum olurdu. Bu durum aynı şekilde personel için de geçerli. Bir personeli hem bulaşıkçı hem garson \r\nhem komi olarak kullanırsak oluşacak sorunları tahmin etmek zor değil. \r\n\r\n   Bu, yazılımımız içindeki ayrıştırma için de önemli. En temelde fonksiyon/metodlarımız tek bir işi yapmalı,\r\nsınıfımız tek bir işe yönelik olmalı, paketimiz/modülümüz/bileşenimiz tek bir işi yapmalı. \r\n\r\n##2) (O)pen/Closed (Geliştirmeye Açık/Değiştirmeye Kapalı) :\r\n   Yine lokantamızın personelini seçerken sadece makarna yapan bir işletme olduğumuz varsayımı ile hareket edecek olursak, \r\n   makarna konusunda genişlemek için minimum değişikikle yapabilmek lazım. Malzeme değişiklikleri ile ürün yelpazesini \r\n   geniş tutmak mümkün olacaktır. \r\n   \r\n   Personelimizi seçerken kendini geliştirebilen personelle çalışmak sık sık personel değişikliği yapmamızın önüne geçer. \r\n\r\n##3) (L)iskov’s Substitution:\r\n   En basit hali ile üretilen yemeğimizin beklentinin çok uzağında olmaması lazım. \r\n   Örneğin müşteri tavkuklu makarna istediği zaman \"makarnalı tavuk\" gelmemeli önüne. \r\n   Ya da \"şef garson\" diye yetiştirilen yada işe alınan bir personelin aşçıbaşı olması durumu nasıl kabul edilemez bir durum ise\r\n   türeyen sınıflarında benzer şekilde planlanması gerekmektedir.\r\n   \r\n##4) (I)Nterface Segregation: \r\n   Bütün personelin ve yemeklerin ana tanımlarının yapılmış olması gerekmektedir. Personel için \"görev tanımı\", \r\n   yemek için \"tarif\" buna örneklenebilir. Ve bu tanım ve tarifleri kullanırken öyle ayrıştırmalıyız ki değişik yapılar için\r\n   sorunlar çıkmasın. Örneğin, kremalı mantarlı tavuklu makarna hazırlanırken krema mantar ve tavuk birlikte soslu halde \r\n   hazır durursa müşteri, \"Ben kremalı mantarlı istiyorum.\" dediğinde sosun içinden tavuk ayıklamak zorunda kalmamak lazım. \r\n   \r\n   Sınıfımızı tanımlarken hem kurallara uydurmalı hemde esnek olmasını sağlamamız gerekmektedir. \r\n   \r\n##5) (D)Ependency Inversion:\r\n  Makarnalarımızı \"Filiz makarnadan\" alıyoruz ibaresinin bulunması ya da personelinizin ismi ile çağrılmasını istemeniz \r\n  bunlara örnektir. Filiz makarna yerine başka makarna kullanmak istediğinizde veya Ertuğrul Şef işten ayrıldığında \r\n  bir bocalama yaşamama şansınız yok. \r\n  \r\n  Aynı şekilde sınıflarımız başka sınıflara, paketlerimiz/modüllerimiz/bileşenlerimiz dışardaki başka yerlere bağımlı olmamalı. \r\n  \r\n  Yukarda kabaca anlatmaya çalıştığım yapılanma ile daha esnek daha az kırılgan ve çalışma iş modelini istediğimiz yere \r\n  uyarlayabilir durumda oluruz. Örnekler çoğaltılabilir. Yazılım açısından bu prensiplerin uygulanmış olması ya da tek başına bu \r\n  kurallara uyulmuş olması önemsizdir. Yazılan kod bir şekilde çalışır. Ancak yazılımın gelişmesi büyümesi ve ölçeklenebilmesi \r\n  açısından Tasarım Desenleri ile birlikte kullanılması ilerleyen projeler için büyük avantaj sağlayacaklardır. \r\n  \r\n  SOLID prensipleri tek başına mucizeler yaratan bir sorun çözücü değildir. Yazılım geliştiricilerin karşılaştığı sorunları \r\n  en aza indirmek için oluşturulmuş şablonlardan bir tanesidir. \r\n  \r\n  Biz yukardaki sayılanları günlük yaşamımızda bir şekilde gerçekleştiriyoruz farkında olmadan. Şimdi yazılım açısından bu \r\n  kuralları örnekleyelim. \r\n  \r\n##1) (S)ingle Responsibility: \r\n\r\n##### Yanlış Örnek: \r\n```php\r\nClass Araba {\r\n   function motor()\r\n   {\r\n     if ($benzinVarmi() != false)\r\n     {\r\n       $motorDurumu = calistir();\r\n     }\r\n   \r\n   }\r\n   \r\n   function benzinVarmi()\r\n   {\r\n     return depoDaNeKadarYakitVar();\r\n   }\r\n   \r\n   function depodaNeKadarYakitVar()\r\n   {\r\n     $depo = $this->depo;\r\n     $yakitDurumu = $depo->yakitDurumu;\r\n     if ($yakitDurumu > 0)\r\n       return $yakitDurumu\r\n     \r\n     return false;\r\n   }\r\n   \r\n   function depoDurumu()\r\n   {\r\n     $yakitYuksekligi = 10;\r\n     $herCmDeKacLitreYakitVar = 4;\r\n     $this->depo = $yakitYuksekligi * $herCmDeKacLitreYakitVar;\r\n   }\r\n}\r\n```\r\n\r\nYukardaki kodumuzda neredeyse bütün kuralları yıkmaya yönelik davrandık :)) \r\n\r\n   Bu örneği daha da uzatabiliriz; bir arabada olması gereken her şeyi burada fonksiyon olarak yazın. \r\nPeki bunun nesi yanlış? Araba sınıfı ve sadece araba ile ilgili fonksiyonlar var. Tek sorumluluk değil mi? \r\n\r\n   İşte burda yazılımcının karar mekanizması devreye giriyor. Şu an bizim yaptğımız şey dökme araba yapmak. \r\nBunu modifiye etmek bazı özelliklerini değiştirmek neredeyse yeni araba yapmaktan daha zor olacak. :) \r\nBunu basitleştirmek için uygun bölümlere ayırmamız gerekiyor. Ve her bölüm için, bölümün yapacağı işi yapmasını sağlıyoruz. \r\nBaşka bir şekilde örnekleyelim. Almanya'da çalışanların genel bir betimlemesi vardır \"Adam fabrikada adam çalıştırıyor \r\nsadece vida sıkmak için.\" Sorumluluk alanı belli ve net sınıflar, metodlar, fonksiyonlar, paketler üretmek yazılımınızı \r\ndaha güçlü kılacaktır. \r\n\r\n##### Doğru Örnek: \r\n```php\r\nClass  Araba {\r\n    function motor()\r\n    {\r\n        $motor = new Motor();\r\n        try {\r\n          $motor->calistir();\r\n        }catch(BenzinException $e)\r\n        {\r\n          Uyari::goster($e->message());\r\n        }\r\n        catch(ArizaException $e)\r\n        {\r\n         Alarm::cal($e->message);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n##2) (O)pen/Closed\r\n\r\n##### Yanlış Örnek: \r\n\r\n```php\r\nClass Notlar {\r\n  public $not1;\r\n  public $not2;\r\n  public $not3;\r\n  protected $sonuc\r\n  \r\n  function hesapla()\r\n  {\r\n        $this->sonuc = ($this->not1 +  $this->not2 + $this->not3)/3;\r\n  }\r\n  \r\n}\r\n```\r\n\r\nBuradaki örnekte fonksiyonumuz sadece hesaplıyor evet. Sorun nerede? Bir not daha eklemek istediğimizde ne olacak? \r\nHatta 2 not ortalamasını nasıl alacağız? Bu kodu geliştirmek için değişiklik yapmak zorundayız. Tabi bu, örnekleme için \r\nçok kaba bir örnek yazılımda istenen şey, bir değişiklik geliştirme yapılacağız zaman önceden yazılmış koda minimum \r\nmüdahale gerekmesi üzerine. \r\n\r\n##### Doğru Örnek: \r\n\r\n```php\r\nClass Notlar {\r\n  public $notlar;\r\n\r\n  protected $sonuc\r\n  \r\n  function hesapla()\r\n  {\r\n        $toplamNot = 0;\r\n        foreach($this->notlar as $not)\r\n        {\r\n            $toplamNot += $not;\r\n        }\r\n        $this->sonuc = $toplamNot/count($this->notlar);\r\n  }\r\n  \r\n}\r\n```\r\n\r\n##3) (L)iskov’s Substitution:\r\n\r\nSOLID prensiplerinden anlaması en zor olanı (bana göre). Çok kaba bir örnek vermek gerekirse; \r\nsiyahi bir çocuk gördüğünüzde anne yada babasının en azından birinin siyahi olmasını beklersiniz.\r\n\r\n##### Yanlış Örnek: \r\n\r\n```php\r\nClass Dikdortgen {\r\n  private $yukseklik;\r\n  private $genislik;\r\n\r\n  protected $alan;\r\n  \r\n  function __set($kenar,$deger)\r\n  {\r\n    $this->$alan = $deger;\r\n  }\r\n  \r\n  \r\n  function alan()\r\n  {\r\n   return $this->yukseklik * $this->genislik;\r\n  }\r\n  \r\n}\r\n\r\nClass Kare Extends Dikdortgen {\r\n  private $yukseklik;\r\n  private $genislik;\r\n\r\n  protected $alan;\r\n  \r\n  function __set($kenar,$deger)\r\n  {\r\n    $this->yukseklik = $this->genislik = $deger;\r\n  }\r\n  \r\n  \r\n  function alan()\r\n  {\r\n   return $this->yukseklik * $this->genislik;\r\n  }\r\n  \r\n}\r\n\r\n$dikdortgen = new Kare();\r\n\r\n$kare->genislik = 5;\r\n$kare->yukseklik = 10; \r\n\r\necho $kare->alan();\r\n```\r\n\r\nYukardaki örnekte basit bir ifade olan \"Dikdörtgenin kenarları eşitse karedir. Ya da her kare bir dikdörtgendir.\" ifadesini \r\nkodlamış durumdayız.\r\n\r\nŞimdi beklenen sonuç = 50 karşılaşılan sonuç = 100\r\n\r\n##4) (I)nterface Segregation\r\nArayüzlerin ayrıştırılması. \r\n\r\nAslında kurduğumuz cümlelerde bu ayrıştırmayı çok seri yapıyoruz fakat kod yazarken bunu gözden çok kaçırıyoruz. \r\nÖrnek : \r\n\"ya 1.6 dizel Renault sedan otomobil aldım\" dediğinizde bunu otomatik yapıyor oluyoruz. \r\n\r\n##### Yanlış Örnek: \r\n```php\r\nClass AldigimAraba implements Cc16DizelSedanInterface\r\n{\r\n  \r\n}\r\n```\r\n##### Doğru Örnek: \r\n```php\r\nClass AldigimAraba implements Cc16InterFace, DizelInterFace, SedanInterFace\r\n{\r\n  \r\n}\r\n```\r\n\r\n##5) (D)ependency Inversion Prensibi\r\n\r\nDışa bağımlılıklarda tek bir yere bağımlı olmama durumunun sağlanması. \r\n\r\n##### Yanlış Örnek: \r\n```php\r\nClass BenzinliMotor()\r\n{\r\n  \r\n  function benzinal()\r\n  {\r\n    $benzinlik = new ShellBenzinlik();\r\n    $benzinlik->pompaci()->doldur(50);\r\n  }\r\n\r\n}\r\n```\r\n   Aldığımız arabada \"Benzini Shell'den alacaksın.\" gibi bir zorunluluk olsa idi ne kadar kızardık değil mi? \r\nFakat kendi sınıflarımıza paketlerimize bileşenlerimize bunu yapmaktan hiç çekinmiyoruz. Neden acaba?\r\n\r\n##### Doğru Örnek: \r\n\r\n```php\r\nClass BenzinliMotor()\r\n{\r\n  \r\n  function benzinal(Benzinlik $benzinlik)\r\n  {\r\n    $benzinlik->pompaci()->doldur(50);\r\n  }\r\n\r\n}\r\n```\r\n\r\nBonus : \r\n\r\n### Inversion Of Control\r\n\r\nŞimdi yukarda örneğimizde Benzinlik olan herhangi bir yere girip benzin alacağımızı belirttik.\r\nPeki \"hangi benzinlik\" olacağına nerde karar vereceğiz? Verdiğimiz kararı nasıl iileteceğiz?\r\n\r\nişte bu yapı için kullanılan yapılardan bir tanesi IoC Container yapısı. \r\nIoC bir zorunluluk değil \"desen,kalıp\" ne diye adlandırırsanız adlandırın \"çözüm\"dür.\r\n\r\nPopüler PHP çatılarından laravel'de IoC çözümlemesi üzerine özellikle durulmuştur. \r\n##Örnek\r\n```php\r\nApp::bind('Benzinlik', function($app)\r\n{\r\n    return new ShellBenzinlik;\r\n});\r\n``` \r\n\r\n##Örnek\r\n```php\r\n        $app->bind('Authority\\Repo\\Session\\SessionInterface', function($app)\r\n        {\r\n            return new SentrySession(\r\n            \t$app['sentry']\r\n            );\r\n        });\r\n\r\n//aşağıdakiinterfaceden üretilmiş bir sınıf tanımlaman lazım :))) namespace kullanmış\r\nnamespace Authority\\Repo\\Session;\r\ninterface SessionInterface\r\n{\r\n\r\n}\r\n```\r\n```php\r\n\r\n        $app->bind('Authority\\Service\\Form\\Login\\LoginForm', function($app) // Loginform $login tanımlarsan\r\n        {\r\n            return new LoginForm(  //LoginForm classında bir nesne yaratırsın\r\n                new LoginFormLaravelValidator( $app['validator'] ), //Loginform() iinde tanımladngına göre constructor, demek ki aynı anda LoginFormlaravelValidator yaratılacak \r\n                $app->make('Authority\\Repo\\Session\\SessionInterface') // ve SessionInterface yaratılacak ? :/ yani LoginForm($param1, $param2) şeklinde o yüzden içini doldurmuş?\r\n            );\r\n        });\r\n        \r\n        \r\n$app->bind('benzinlik',$app)\r\n{\r\n    return new ShellBenzinlik();\r\n} \r\n\r\n\r\n//LoginForm.php nin constructor u\r\n\tpublic function __construct(ValidableInterface $validator, SessionInterface $session) //demek ki doğru anlamısım\r\n\t{\r\n\t\t$this->validator = $validator;\r\n\t\t$this->session = $session;\r\n\t}\r\n\r\n\r\n\r\n\r\n//Burda tanımladığın şeyi kullanmak için\r\n\r\n$benzinlik = $app->make('benzinlik'); \r\n```\r\n#Teşekkürler\r\nSOLID prensiplerini anlamamda ve bu dökümanı hazırlamamda kaynak olan yazı : \r\nhttp://www.clubcrema.com/index.php/2013/05/solid-prensipleri-solid-principles/\t\t\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}